<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>AUV-Coop-Assembly: Detector Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AUV-Coop-Assembly
   </div>
   <div id="projectbrief">Master Thesis for Robotics Engineering. Cooperative peg-in-hole assembly with two underwater vehicles guided by vision</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classDetector-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Detector Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:abc387e4df48e9ef8928941d916dc40a9"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDetector.html#abc387e4df48e9ef8928941d916dc40a9">templateMatching</a> (cv::Mat img, std::vector&lt; cv::Mat &gt; templVector, std::vector&lt; std::vector&lt; cv::Point &gt;&gt; *found4CornersVector, std::vector&lt; double &gt; *bestValues, int templ_method=cv::TM_SQDIFF, std::vector&lt; double &gt; scaleFactors=std::vector&lt; double &gt;(), bool showDisplay=true)</td></tr>
<tr class="memdesc:abc387e4df48e9ef8928941d916dc40a9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classDetector.html#abc387e4df48e9ef8928941d916dc40a9" title="Detector::templateMatching check function below, this one is used if multiple templates want be used...">Detector::templateMatching</a> check function below, this one is used if multiple templates want be used.  <a href="#abc387e4df48e9ef8928941d916dc40a9">More...</a><br /></td></tr>
<tr class="separator:abc387e4df48e9ef8928941d916dc40a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe2c946683115ab48c1743034cbdcd65"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDetector.html#afe2c946683115ab48c1743034cbdcd65">templateMatching</a> (cv::Mat img, cv::Mat templ, std::vector&lt; cv::Point &gt; *found4Corners, double *bestValue=NULL, int templ_method=cv::TM_SQDIFF, std::vector&lt; double &gt; scaleFactors=std::vector&lt; double &gt;(), bool showDisplay=true)</td></tr>
<tr class="memdesc:afe2c946683115ab48c1743034cbdcd65"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classDetector.html#abc387e4df48e9ef8928941d916dc40a9" title="Detector::templateMatching check function below, this one is used if multiple templates want be used...">Detector::templateMatching</a> template Matching method using opencv functions. Various method can be choosen It detects the template and return a rectangle (represented as the 4 corners) around the best match. So if a precise detection is needed, template and image should have same rotation, and be both square as possible. Size of template is not important because various scaling of the original image are tried and the best match returned (i.e. scale invariant template matching)  <a href="#afe2c946683115ab48c1743034cbdcd65">More...</a><br /></td></tr>
<tr class="separator:afe2c946683115ab48c1743034cbdcd65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28d55b0bfff8c1b35c4a66949cd07451"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDetector.html#a28d55b0bfff8c1b35c4a66949cd07451">drawSquares</a> (cv::Mat image, const std::vector&lt; std::vector&lt; cv::Point &gt; &gt; squares, const char *wndname=&quot;Square Detection Demo&quot;)</td></tr>
<tr class="memdesc:a28d55b0bfff8c1b35c4a66949cd07451"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classDetector.html#a28d55b0bfff8c1b35c4a66949cd07451" title="Detector::drawSquares function to draw square in images. ">Detector::drawSquares</a> function to draw square in images.  <a href="#a28d55b0bfff8c1b35c4a66949cd07451">More...</a><br /></td></tr>
<tr class="separator:a28d55b0bfff8c1b35c4a66949cd07451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3fb97632fbaa89f79fea08bdd5e3d90"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDetector.html#ac3fb97632fbaa89f79fea08bdd5e3d90">findSquare</a> (cv::Mat &amp;image, std::vector&lt; std::vector&lt; cv::Point &gt;&gt; *found4CornersVector, int threshLevels=11, int cannyThresh=50)</td></tr>
<tr class="memdesc:ac3fb97632fbaa89f79fea08bdd5e3d90"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classDetector.html#ac3fb97632fbaa89f79fea08bdd5e3d90" title="Detector::findSquare find all square in images, exploiting functions of opencv. In practice is a blob...">Detector::findSquare</a> find all square in images, exploiting functions of opencv. In practice is a blob detector but specific for the squares, e.g. it check if polygon founded have 4 side and four 90 degree angle (with some margins), and of a certain minimum area (to ot consider false positive). Code from opencv tutorial: <a href="https://docs.opencv.org/3.4/db/d00/samples_2cpp_2squares_8cpp-example.html#a20">https://docs.opencv.org/3.4/db/d00/samples_2cpp_2squares_8cpp-example.html#a20</a>.  <a href="#ac3fb97632fbaa89f79fea08bdd5e3d90">More...</a><br /></td></tr>
<tr class="separator:ac3fb97632fbaa89f79fea08bdd5e3d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock">
<p>Definition at line <a class="el" href="detector_8h_source.html#l00012">12</a> of file <a class="el" href="detector_8h_source.html">detector.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a28d55b0bfff8c1b35c4a66949cd07451"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Detector::drawSquares </td>
          <td>(</td>
          <td class="paramtype">cv::Mat&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; cv::Point &gt; &gt;&#160;</td>
          <td class="paramname"><em>squares</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>wndname</em> = <code>&quot;Square&#160;Detection&#160;Demo&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classDetector.html#a28d55b0bfff8c1b35c4a66949cd07451" title="Detector::drawSquares function to draw square in images. ">Detector::drawSquares</a> function to draw square in images. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000007">Todo:</a></b></dt><dd>check if original image is modified </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td></td></tr>
    <tr><td class="paramname">squares</td><td></td></tr>
    <tr><td class="paramname">wndname</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="detector_8cpp_source.html#l00053">53</a> of file <a class="el" href="detector_8cpp_source.html">detector.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac3fb97632fbaa89f79fea08bdd5e3d90"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Detector::findSquare </td>
          <td>(</td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; cv::Point &gt;&gt; *&#160;</td>
          <td class="paramname"><em>found4CornersVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threshLevels</em> = <code>11</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cannyThresh</em> = <code>50</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classDetector.html#ac3fb97632fbaa89f79fea08bdd5e3d90" title="Detector::findSquare find all square in images, exploiting functions of opencv. In practice is a blob...">Detector::findSquare</a> find all square in images, exploiting functions of opencv. In practice is a blob detector but specific for the squares, e.g. it check if polygon founded have 4 side and four 90 degree angle (with some margins), and of a certain minimum area (to ot consider false positive). Code from opencv tutorial: <a href="https://docs.opencv.org/3.4/db/d00/samples_2cpp_2squares_8cpp-example.html#a20">https://docs.opencv.org/3.4/db/d00/samples_2cpp_2squares_8cpp-example.html#a20</a>. </p>
<p>functions for METHOD FIND SQUARES </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>in which look for squares. Both gray and colored image are accepted </td></tr>
    <tr><td class="paramname">*found4CornersVector</td><td>OUT each element contain a vector of 4 point (ie, defining a square). </td></tr>
    <tr><td class="paramname">threshLevels</td><td>OPTIONAL number of threshold level. The more they are the more the result is good, but obviously also more computation time </td></tr>
    <tr><td class="paramname">threshold</td><td>for opencv Canny function, it is the maximum threshold. Canny is used only once, for the thresholdLevel equal to zero. Check _findSquares comments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 correct execution </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Please note that there is no way to understand which is the more precise square (if they are more than one). Various trial show that is the squares are more than one, they are almost on the same position, so they are not really false positive (it is because we have three channels one for each color so a squares is detected for each channel. </dd>
<dd>
If a colored image is used, the result will be more precise because detection is done on each color channel. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000006">Todo:</a></b></dt><dd>various parameters are hardcoded in _findSquares. Maybe they can be setted from external caller. </dd></dl>

<p>Definition at line <a class="el" href="detector_8cpp_source.html#l00028">28</a> of file <a class="el" href="detector_8cpp_source.html">detector.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="abc387e4df48e9ef8928941d916dc40a9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Detector::templateMatching </td>
          <td>(</td>
          <td class="paramtype">cv::Mat&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; cv::Mat &gt;&#160;</td>
          <td class="paramname"><em>templVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; cv::Point &gt;&gt; *&#160;</td>
          <td class="paramname"><em>found4CornersVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>bestValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>templ_method</em> = <code>cv::TM_SQDIFF</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>scaleFactors</em> = <code>std::vector&lt;double&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>showDisplay</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classDetector.html#abc387e4df48e9ef8928941d916dc40a9" title="Detector::templateMatching check function below, this one is used if multiple templates want be used...">Detector::templateMatching</a> check function below, this one is used if multiple templates want be used. </p>
<p>functions for METHOD TEMPLATE MATCHING </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img</td><td>image input where to find the match </td></tr>
    <tr><td class="paramname">templVector</td><td>vector of templates </td></tr>
    <tr><td class="paramname">*found4CornersVector</td><td>OUT each element will contain the 4 corners for each template </td></tr>
    <tr><td class="paramname">*bestValues</td><td>OUT each element will contain the best value for each template (warning at MIN MAX based on method) </td></tr>
    <tr><td class="paramname">templ_method</td><td>OPTIONAL 0 TM_SQDIFF : squared differences (BEST is MIN) 1 SQDIFF_NORMED: squared differences normed (BEST is MIN) 2 CCORR : cross correlation? (BEST is MAX) 3 CCORR_NORMED cross correlation normed? (BEST is MAX) 4 CCOEFF: ? (BEST is MAX) 5 CCOEFF_NORMED: ? (BEST is MAX) </td></tr>
    <tr><td class="paramname">scaleFactors</td><td>OPTIONAL the list of scaling factor default one is provided in the code </td></tr>
    <tr><td class="paramname">showDisplay</td><td>OPTIONAL, choose if show template matching result in a window image </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 correct execution </dd></dl>

<p>Definition at line <a class="el" href="detector_8cpp_source.html#l00269">269</a> of file <a class="el" href="detector_8cpp_source.html">detector.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="afe2c946683115ab48c1743034cbdcd65"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Detector::templateMatching </td>
          <td>(</td>
          <td class="paramtype">cv::Mat&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat&#160;</td>
          <td class="paramname"><em>templ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; cv::Point &gt; *&#160;</td>
          <td class="paramname"><em>found4Corners</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>bestValue</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>templ_method</em> = <code>cv::TM_SQDIFF</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>scaleFactors</em> = <code>std::vector&lt;double&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>showDisplay</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classDetector.html#abc387e4df48e9ef8928941d916dc40a9" title="Detector::templateMatching check function below, this one is used if multiple templates want be used...">Detector::templateMatching</a> template Matching method using opencv functions. Various method can be choosen It detects the template and return a rectangle (represented as the 4 corners) around the best match. So if a precise detection is needed, template and image should have same rotation, and be both square as possible. Size of template is not important because various scaling of the original image are tried and the best match returned (i.e. scale invariant template matching) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img</td><td>image input where to find the match </td></tr>
    <tr><td class="paramname">templ</td><td>the template </td></tr>
    <tr><td class="paramname">*found4Corners</td><td>OUT the founded4Corners passed by reference </td></tr>
    <tr><td class="paramname">*bestValue</td><td>OUT OPTIONAL the value of the best match among all scalings. NOTE that depending on method can be a MAX or MIN value </td></tr>
    <tr><td class="paramname">templ_method</td><td>OPTIONAL 0 TM_SQDIFF : squared differences (BEST is MIN) 1 SQDIFF_NORMED: squared differences normed (BEST is MIN) 2 CCORR : cross correlation? (BEST is MAX) 3 CCORR_NORMED cross correlation normed? (BEST is MAX) 4 CCOEFF: ? (BEST is MAX) 5 CCOEFF_NORMED: ? (BEST is MAX) </td></tr>
    <tr><td class="paramname">scaleFactors</td><td>OPTIONAL the list of scaling factor default one is provided in the code </td></tr>
    <tr><td class="paramname">showDisplay</td><td>OPTIONAL, choose if show template matching result in a window image </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the found4Corners are in CLOCKWISE order beginning from the TOP LEFT </dd>
<dd>
template matching is good until no lighthing/transformations can happen, so not really suitable for continuosly detect something in a video. </dd>
<dd>
there is not a huge difference between the different summing methods, formulas can be found in the opencv documentation : </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>0 correct execution </dd></dl>

<p>Definition at line <a class="el" href="detector_8cpp_source.html#l00315">315</a> of file <a class="el" href="detector_8cpp_source.html">detector.cpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/peg/src/vision/header/<a class="el" href="detector_8h_source.html">detector.h</a></li>
<li>src/peg/src/vision/<a class="el" href="detector_8cpp_source.html">detector.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
